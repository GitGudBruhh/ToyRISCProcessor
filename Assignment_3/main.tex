\documentclass[12pt,a4paper]{article}
\usepackage{graphicx}
\usepackage{multicol}
\setlength{\columnsep}{1cm}
% \usepackage[english]{babel}
% \usepackage[utf8x]{inputenc}

\usepackage{graphicx} % Required for inserting images.
\usepackage[margin=25mm]{geometry}
\parskip 4.2pt  % Sets spacing between paragraphs.
% \renewcommand{\baselinestretch}{1.5}  % Uncomment for 1.5 spacing between lines.
\parindent 8.4pt  % Sets leading space for paragraphs.
\usepackage[font=sf]{caption} % Changes font of captions.

\usepackage{amsmath}
\usepackage{amsfonts}
\usepackage{amssymb}
\usepackage{siunitx}
\usepackage{verbatim}
\usepackage{hyperref} % Required for inserting clickable links.
\usepackage{natbib} % Required for APA-style citations.


\title{\textbf{ASSIGNMENT 3}}
\author{Sachin Kumar(220120019), Amogh R (220010005)}
\date{}


\begin{document}
\maketitle

\section{Introduction}\label{sec:intro}
In ths assignment, we have created a working simulator for ToyRISC.
The simulator simulates a single-cycle processor which works on the ToyRISC ISA.
The five stages implemented in the simulator are:
\begin{enumerate}
    \item Instruction Fetch Unit
    \item Operand Fetch Unit
    \item Execute Unit
    \item Memory Access Unit
    \item Register Write Unit
\end{enumerate}
An additional Control Unit has been created which provides the control signals for every instruction the Operand Fetch Unit receives.

\section{Working of the processor}
The simulator is programmed to be as close as possible to an actual single cycle processor.
The \texttt{ControlUnit} is a separate object we have created, which generates a \texttt{ControlSignals} object for every instruction. The \texttt{ControlSignals} object contains a boolean array for each operation signal and miscellaneous signals.

The program works as follows:
\begin{enumerate}
    \item The \texttt{main()} function calls the function \texttt{simulate()}, which loads the object file into memory using the \texttt{loadProgram()} function.
    \item The Simulator begins the simulation by looping through the five stages of the processor. Initially, a flag called \texttt{isIdle} is set to true for the processor object, which says that the processor has not started execution of any program. One the Instruction Fetch unit fetches an instruction, it sets the processors state to 'not idle'.
    \item The program continues execution with each instruction passing through their corresponding latches, per cycle.
    \item As the number of cycles is synced to the number of instructions executed, there is no difference between their magnitude.
    \item The \texttt{end} instruction when read, sets the processor back to its idle state. The simulator then ends the loop and writes the statistics to a file.
\end{enumerate}

\section{Testing}
The simulator was tested on the following files from Assignment 1:
\begin{enumerate}
    \item \texttt{descending.asm}
        \subitem Number of instructions: 288
        \subitem Number of cycles: 288
    \item \texttt{fibonacci.asm}
        \subitem Number of instructions: 114
        \subitem Number of cycles: 114
    \item \texttt{even\_odd.asm}
        \subitem Number of instructions: 222
        \subitem Number of cycles: 222
    \item \texttt{prime.asm}
        \subitem Number of instructions: 11
        \subitem Number of cycles: 11
    \item \texttt{palindrome.asm}
        \subitem Number of instructions: 31
        \subitem Number of cycles: 31
\end{enumerate}

The simulator was tested on the same files provided as supporting files:
\begin{enumerate}
	\item \texttt{descending.asm}
	\subitem Number of instructions: 277
	\subitem Number of cycles: 277
	\item \texttt{fibonacci.asm}
	\subitem Number of instructions: 78
	\subitem Number of cycles: 78
	\item \texttt{even\_odd.asm}
	\subitem Number of instructions: 6
	\subitem Number of cycles: 6
	\item \texttt{prime.asm}
	\subitem Number of instructions: 29
	\subitem Number of cycles: 29
	\item \texttt{palindrome.asm}
	\subitem Number of instructions: 49
	\subitem Number of cycles: 49
\end{enumerate}

\section{Conclusion}
The number of dynamic instructions executed here is equal to the number of cycles as no pipelining has been implemented.
Also, the high numbers of dynamic instructions is partly because of unoptimized register read-writes from the programmer's side.
\end{document}